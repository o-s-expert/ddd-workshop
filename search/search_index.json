{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this workshop This workshop will explore Domain-Driven Design (DDD) through practical actions when developing Java solutions. We will begin with the strategic perspective , covering essential concepts such as domains and subdomains, ubiquitous language, bounded contexts, and context mapping . These foundations will help us understand how to align software models with business needs and design systems that evolve with clarity. From there, we move into the tactical building blocks \u2014including entities, value objects, aggregates, repositories, factories, domain services, domain events, and application services \u2014to see how business rules are modeled directly in code. We will also explore how DDD fits into layered architecture (presentation, application, domain, and infrastructure) and connect it with the persistence layer using Jakarta EE, Jakarta Data, and Jakarta NoSQL . Hands-on labs will guide us through implementing these concepts step by step, applying DDD patterns in real Java code to reinforce both theory and practice. What we will learn This workshop will provide a clear understanding of how Domain-Driven Design (DDD) guides both the strategic and tactical aspects of software design. Participants will learn how to connect business language to code and how to implement domain models effectively in Java. By combining theory with hands-on coding, you will see how DDD patterns translate directly into maintainable and scalable applications. Objectives Understand the difference between strategic DDD (domains, subdomains, ubiquitous language, bounded contexts, context mapping) and tactical DDD (entities, value objects, aggregates, repositories, factories, domain services, domain events, and application services). Recognize how DDD fits into a layered architecture and supports clean separation of concerns. Explore how persistence can be handled using Jakarta EE, Jakarta Data, and Jakarta NoSQL . Apply DDD patterns step by step in hands-on labs , reinforcing theory through practice. Takeaways By the end of the workshop, you will: - Be able to identify and model business domains and subdomains. - Use a ubiquitous language to improve communication between developers and domain experts. - Implement DDD tactical patterns directly in Java with confidence. - Understand how layered architecture supports DDD. - Gain practical experience with persistence using Jakarta EE and Jakarta NoSQL . - Walk away with code examples and labs you can adapt to your own projects.","title":"About this workshop"},{"location":"#about-this-workshop","text":"This workshop will explore Domain-Driven Design (DDD) through practical actions when developing Java solutions. We will begin with the strategic perspective , covering essential concepts such as domains and subdomains, ubiquitous language, bounded contexts, and context mapping . These foundations will help us understand how to align software models with business needs and design systems that evolve with clarity. From there, we move into the tactical building blocks \u2014including entities, value objects, aggregates, repositories, factories, domain services, domain events, and application services \u2014to see how business rules are modeled directly in code. We will also explore how DDD fits into layered architecture (presentation, application, domain, and infrastructure) and connect it with the persistence layer using Jakarta EE, Jakarta Data, and Jakarta NoSQL . Hands-on labs will guide us through implementing these concepts step by step, applying DDD patterns in real Java code to reinforce both theory and practice.","title":"About this workshop"},{"location":"#what-we-will-learn","text":"This workshop will provide a clear understanding of how Domain-Driven Design (DDD) guides both the strategic and tactical aspects of software design. Participants will learn how to connect business language to code and how to implement domain models effectively in Java. By combining theory with hands-on coding, you will see how DDD patterns translate directly into maintainable and scalable applications.","title":"What we will learn"},{"location":"#objectives","text":"Understand the difference between strategic DDD (domains, subdomains, ubiquitous language, bounded contexts, context mapping) and tactical DDD (entities, value objects, aggregates, repositories, factories, domain services, domain events, and application services). Recognize how DDD fits into a layered architecture and supports clean separation of concerns. Explore how persistence can be handled using Jakarta EE, Jakarta Data, and Jakarta NoSQL . Apply DDD patterns step by step in hands-on labs , reinforcing theory through practice.","title":"Objectives"},{"location":"#takeaways","text":"By the end of the workshop, you will: - Be able to identify and model business domains and subdomains. - Use a ubiquitous language to improve communication between developers and domain experts. - Implement DDD tactical patterns directly in Java with confidence. - Understand how layered architecture supports DDD. - Gain practical experience with persistence using Jakarta EE and Jakarta NoSQL . - Walk away with code examples and labs you can adapt to your own projects.","title":"Takeaways"},{"location":"00_environment/","text":"Preparing your environment Most of the workshop exercises involves usage of tools such as: - Developer IDE (e.g. VSCode, Eclipse, IntelliJ, ...) - Egon.io - CLI tools via terminal - Maven - Docker - Docker Compose - Postman (Optional) Prerequisites Maven CLI; Git CLI; Java 21; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; REST client tools like cURL or postman (Optional) ; Docker and Docker Compose. Postman (Optional) java -version mvn -version git --version To validate your environment, confirm you have as an output of the commands above working: $ java -version openjdk version \"21.0.7\" 2025 -04-15 LTS OpenJDK Runtime Environment Temurin-21.0.7+6 ( build 21 .0.7+6-LTS ) OpenJDK 64 -Bit Server VM Temurin-21.0.7+6 ( build 21 .0.7+6-LTS, mixed mode, sharing ) $ mvn -version Apache Maven 3 .9.9 ( 8e8579a9e76f7d015ee5ec7bfcdc97d260186937 ) Maven home: /Users/otaviosantana/.sdkman/candidates/maven/current Java version: 21 .0.7, vendor: Eclipse Adoptium, runtime: /Users/otaviosantana/.sdkman/candidates/java/21.0.7-tem Default locale: en_US, platform encoding: UTF-8 OS name: \"mac os x\" , version: \"15.6.1\" , arch: \"aarch64\" , family: \"mac\" $ git --version git version 2 .39.5 ( Apple Git-154 ) $ docker --version Docker version 28 .3.2, build 578ccf6 $ docker compose version Docker Compose version v2.39.1-desktop.1 Prepare your working directory To get started with the labs, first you need to clone the projects used in the exercises and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/ultimate-engineer/ddd-workshop-labs cd ddd-workshop-labs mvn clean package docker-compose up -d The build and packaging should complete successfully.","title":"Preparing your environment"},{"location":"00_environment/#preparing-your-environment","text":"Most of the workshop exercises involves usage of tools such as: - Developer IDE (e.g. VSCode, Eclipse, IntelliJ, ...) - Egon.io - CLI tools via terminal - Maven - Docker - Docker Compose - Postman (Optional)","title":"Preparing your environment"},{"location":"00_environment/#prerequisites","text":"Maven CLI; Git CLI; Java 21; An IDE of your preference; Command line (terminal). If using Windows, PowerShell is recommended; REST client tools like cURL or postman (Optional) ; Docker and Docker Compose. Postman (Optional) java -version mvn -version git --version To validate your environment, confirm you have as an output of the commands above working: $ java -version openjdk version \"21.0.7\" 2025 -04-15 LTS OpenJDK Runtime Environment Temurin-21.0.7+6 ( build 21 .0.7+6-LTS ) OpenJDK 64 -Bit Server VM Temurin-21.0.7+6 ( build 21 .0.7+6-LTS, mixed mode, sharing ) $ mvn -version Apache Maven 3 .9.9 ( 8e8579a9e76f7d015ee5ec7bfcdc97d260186937 ) Maven home: /Users/otaviosantana/.sdkman/candidates/maven/current Java version: 21 .0.7, vendor: Eclipse Adoptium, runtime: /Users/otaviosantana/.sdkman/candidates/java/21.0.7-tem Default locale: en_US, platform encoding: UTF-8 OS name: \"mac os x\" , version: \"15.6.1\" , arch: \"aarch64\" , family: \"mac\" $ git --version git version 2 .39.5 ( Apple Git-154 ) $ docker --version Docker version 28 .3.2, build 578ccf6 $ docker compose version Docker Compose version v2.39.1-desktop.1","title":"Prerequisites"},{"location":"00_environment/#prepare-your-working-directory","text":"To get started with the labs, first you need to clone the projects used in the exercises and have it available in your local development environment. Info The guided exercises are built on top of quickstart projects, a foundation set of preconfigured projects. To get the foundation projects and build them, execute: git clone https://github.com/ultimate-engineer/ddd-workshop-labs cd ddd-workshop-labs mvn clean package docker-compose up -d The build and packaging should complete successfully.","title":"Prepare your working directory"},{"location":"01_context_mapping/","text":"1 Understanding Context Mapping To see the diagrams properly, please open them in Mermaid Live Editor . Or you can use the following link: See at Github Page Shared Kernel- A Common Ground Two contexts share a part of the model, requiring close coordination and trust between teams. flowchart LR subgraph C1[\"Context A\"] A1[Domain Model A] end subgraph C2[\"Context B\"] B1[Domain Model B] end SK[(Shared Kernel<br/>Shared Model Part)] A1 --- SK B1 --- SK Customer\u2013Supplier The downstream (customer) depends on the upstream (supplier) and can influence its priorities or features. flowchart LR subgraph U[\"Upstream (Supplier)\"] U1[Payments Service] end subgraph D[\"Downstream (Customer)\"] D1[Orders Service] end U1 -- \"Provides functionality\" --> D1 D1 -- \"Influences requirements\" --> U1 Conformist The downstream has no influence and must fully adapt to the upstream model as it is. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments] end PL[(Published Model / Contract)] subgraph D[\"Downstream Context\"] D1[Orders] end U1 -- \"Owns & defines\" --> PL D1 -- \"Conforms to\" --> PL D1 -. \"No influence on Upstream\" .- U1 D1 -. \"No influence on Downstream\" .- U1 Anticorruption Layer The downstream isolates its domain by translating the upstream model, preventing external concepts from leaking in. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments] end subgraph D[\"Downstream Context\"] D1[Orders] end ACL[\"`Anticorruption Layer`\"] U1 -- \"Provides Model\" --> ACL ACL -- \"Translates & Protects\" --> D1 D1 -. \"Own domain language preserved\" .- D1 Published Language Teams agree on a shared, well-defined communication language or schema to integrate smoothly. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments Supplier] end PL[(Published Language<br/>OpenAPI / Avro / JSON Schema)] subgraph D[\"Downstream Contexts\"] D1[Orders Customer] D2[Analytics] D3[Billing Reconciliation] end U1 -- Publishes --> PL D1 -- Consumes --> PL D2 -- Consumes --> PL D3 -- Consumes --> PL Separate Ways Contexts remain isolated, evolving independently without integration. flowchart LR subgraph A[\"Context A\"] A1[Payments] end subgraph B[\"Context B\"] B1[Orders] end A -. \"No integration\" .- B Open Host Service The upstream provides a well-defined API or protocol that multiple downstreams can consume without tight coupling. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments Service] end OHS[(Open Host Service<br/>Public API / Protocol)] subgraph D[\"Downstream Contexts\"] D1[Orders] D2[Analytics] end U1 -- \"Exposes API\" --> OHS D1 -- \"Consumes API\" --> OHS D2 -- \"Consumes API\" --> OHS","title":"1 Understanding Context Mapping"},{"location":"01_context_mapping/#1-understanding-context-mapping","text":"To see the diagrams properly, please open them in Mermaid Live Editor . Or you can use the following link: See at Github Page","title":"1 Understanding Context Mapping"},{"location":"01_context_mapping/#shared-kernel-a-common-ground","text":"Two contexts share a part of the model, requiring close coordination and trust between teams. flowchart LR subgraph C1[\"Context A\"] A1[Domain Model A] end subgraph C2[\"Context B\"] B1[Domain Model B] end SK[(Shared Kernel<br/>Shared Model Part)] A1 --- SK B1 --- SK","title":"Shared Kernel- A Common Ground"},{"location":"01_context_mapping/#customersupplier","text":"The downstream (customer) depends on the upstream (supplier) and can influence its priorities or features. flowchart LR subgraph U[\"Upstream (Supplier)\"] U1[Payments Service] end subgraph D[\"Downstream (Customer)\"] D1[Orders Service] end U1 -- \"Provides functionality\" --> D1 D1 -- \"Influences requirements\" --> U1","title":"Customer\u2013Supplier"},{"location":"01_context_mapping/#conformist","text":"The downstream has no influence and must fully adapt to the upstream model as it is. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments] end PL[(Published Model / Contract)] subgraph D[\"Downstream Context\"] D1[Orders] end U1 -- \"Owns & defines\" --> PL D1 -- \"Conforms to\" --> PL D1 -. \"No influence on Upstream\" .- U1 D1 -. \"No influence on Downstream\" .- U1","title":"Conformist"},{"location":"01_context_mapping/#anticorruption-layer","text":"The downstream isolates its domain by translating the upstream model, preventing external concepts from leaking in. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments] end subgraph D[\"Downstream Context\"] D1[Orders] end ACL[\"`Anticorruption Layer`\"] U1 -- \"Provides Model\" --> ACL ACL -- \"Translates & Protects\" --> D1 D1 -. \"Own domain language preserved\" .- D1","title":"Anticorruption Layer"},{"location":"01_context_mapping/#published-language","text":"Teams agree on a shared, well-defined communication language or schema to integrate smoothly. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments Supplier] end PL[(Published Language<br/>OpenAPI / Avro / JSON Schema)] subgraph D[\"Downstream Contexts\"] D1[Orders Customer] D2[Analytics] D3[Billing Reconciliation] end U1 -- Publishes --> PL D1 -- Consumes --> PL D2 -- Consumes --> PL D3 -- Consumes --> PL","title":"Published Language"},{"location":"01_context_mapping/#separate-ways","text":"Contexts remain isolated, evolving independently without integration. flowchart LR subgraph A[\"Context A\"] A1[Payments] end subgraph B[\"Context B\"] B1[Orders] end A -. \"No integration\" .- B","title":"Separate Ways"},{"location":"01_context_mapping/#open-host-service","text":"The upstream provides a well-defined API or protocol that multiple downstreams can consume without tight coupling. flowchart LR subgraph U[\"Upstream Context\"] U1[Payments Service] end OHS[(Open Host Service<br/>Public API / Protocol)] subgraph D[\"Downstream Contexts\"] D1[Orders] D2[Analytics] end U1 -- \"Exposes API\" --> OHS D1 -- \"Consumes API\" --> OHS D2 -- \"Consumes API\" --> OHS","title":"Open Host Service"},{"location":"02_tactic_pattern/","text":"2 Tactic Patterns To see the diagrams properly, please open them in Mermaid Live Editor . Or you can use the following link: See at Github Page Entity \u2013 Identity Matters An object defined by a unique identity that persists over time, even if its attributes change. classDiagram class Customer { -id : UUID -name : String -email : String +changeEmail(newEmail) : void } Value Object \u2013 Essence over Identity An immutable object defined solely by its attributes; equality is based on value rather than identity. classDiagram class Email { -address : String +Email(address) } class Money { -amount : decimal -currency : String +Money(amount, currency) +add(other: Money) : Money } Aggregate \u2013 Consistency Boundary A cluster of entities and value objects treated as a single unit, with a root entity ensuring business rules and consistency. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus -items : List~OrderItem~ +addItem(product: Product, quantity: int) : void +changeItemQuantity(product: Product, quantity: int) : void +removeItem(product: Product) : void +confirm() : void -enforceInvariants() : void } class OrderItem { <<entity>> -id : UUID -product : Product -quantity : int } class Product { <<entity>> -id : UUID +name : String } class OrderStatus Order \"1\" o-- \"1..*\" OrderItem OrderItem --> Product Order --> OrderStatus Repository \u2013 Gateway to Aggregates An abstraction that provides controlled access to aggregates, handling persistence while keeping the domain pure. classDiagram class Order { <<aggregate root>> -id : UUID } class OrderRepository { <<interface>> +save(order: Order) : void +findById(id: UUID) : Order? +delete(id: UUID) : void +findByCustomer(customerId: UUID) : List~Order~ } OrderRepository --> Order : returns/manages Factory \u2013 Controlled Creation A mechanism that encapsulates complex creation logic, ensuring invariants are satisfied when building aggregates or entities. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus } class OrderFactory { <<factory>> +create(customerId: UUID) : Order +reconstruct(id: UUID, status: OrderStatus) : Order } OrderFactory --> Order : creates Domain Service \u2013 Logic Without a Home Encapsulates domain behavior that does not naturally belong to an entity or value object, but is still part of the core domain. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus } class OrderPricingService { <<domain service>> +calculateTotal(order: Order) : Money +applyBusinessRules(order: Order) : void } OrderPricingService --> Order : operates on Domain Event \u2013 Something Happened Represents a significant occurrence in the domain, capturing a past fact and enabling communication across the system. classDiagram class Order { <<aggregate root>> -id : UUID +confirm() : void } class OrderConfirmedEvent { <<domain event>> -orderId : UUID +occurredOn : DateTime } Order --> OrderConfirmedEvent : \"publishes\" Application Service - Orchestrating Use Cases An application service coordinates workflows by invoking domain objects and repositories, ensuring the correct sequence of operations. It manages transactions, orchestration, and security while delegating all business rules to the domain layer, keeping the domain pure and exposing use cases to the outside world. classDiagram class Order { <<aggregate root>> -id : UUID +confirm() : void } class OrderRepository { <<repository>> +findById(id: UUID) : Order +save(order: Order) : void } class OrderApplicationService { <<application service>> +confirmOrder(orderId: UUID) : void } OrderApplicationService --> OrderRepository : uses OrderApplicationService --> Order : orchestrates","title":"2 Tactic Patterns"},{"location":"02_tactic_pattern/#2-tactic-patterns","text":"To see the diagrams properly, please open them in Mermaid Live Editor . Or you can use the following link: See at Github Page","title":"2 Tactic Patterns"},{"location":"02_tactic_pattern/#entity-identity-matters","text":"An object defined by a unique identity that persists over time, even if its attributes change. classDiagram class Customer { -id : UUID -name : String -email : String +changeEmail(newEmail) : void }","title":"Entity \u2013 Identity Matters"},{"location":"02_tactic_pattern/#value-object-essence-over-identity","text":"An immutable object defined solely by its attributes; equality is based on value rather than identity. classDiagram class Email { -address : String +Email(address) } class Money { -amount : decimal -currency : String +Money(amount, currency) +add(other: Money) : Money }","title":"Value Object \u2013 Essence over Identity"},{"location":"02_tactic_pattern/#aggregate-consistency-boundary","text":"A cluster of entities and value objects treated as a single unit, with a root entity ensuring business rules and consistency. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus -items : List~OrderItem~ +addItem(product: Product, quantity: int) : void +changeItemQuantity(product: Product, quantity: int) : void +removeItem(product: Product) : void +confirm() : void -enforceInvariants() : void } class OrderItem { <<entity>> -id : UUID -product : Product -quantity : int } class Product { <<entity>> -id : UUID +name : String } class OrderStatus Order \"1\" o-- \"1..*\" OrderItem OrderItem --> Product Order --> OrderStatus","title":"Aggregate \u2013 Consistency Boundary"},{"location":"02_tactic_pattern/#repository-gateway-to-aggregates","text":"An abstraction that provides controlled access to aggregates, handling persistence while keeping the domain pure. classDiagram class Order { <<aggregate root>> -id : UUID } class OrderRepository { <<interface>> +save(order: Order) : void +findById(id: UUID) : Order? +delete(id: UUID) : void +findByCustomer(customerId: UUID) : List~Order~ } OrderRepository --> Order : returns/manages","title":"Repository \u2013 Gateway to Aggregates"},{"location":"02_tactic_pattern/#factory-controlled-creation","text":"A mechanism that encapsulates complex creation logic, ensuring invariants are satisfied when building aggregates or entities. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus } class OrderFactory { <<factory>> +create(customerId: UUID) : Order +reconstruct(id: UUID, status: OrderStatus) : Order } OrderFactory --> Order : creates","title":"Factory \u2013 Controlled Creation"},{"location":"02_tactic_pattern/#domain-service-logic-without-a-home","text":"Encapsulates domain behavior that does not naturally belong to an entity or value object, but is still part of the core domain. classDiagram class Order { <<aggregate root>> -id : UUID -status : OrderStatus } class OrderPricingService { <<domain service>> +calculateTotal(order: Order) : Money +applyBusinessRules(order: Order) : void } OrderPricingService --> Order : operates on","title":"Domain Service \u2013 Logic Without a Home"},{"location":"02_tactic_pattern/#domain-event-something-happened","text":"Represents a significant occurrence in the domain, capturing a past fact and enabling communication across the system. classDiagram class Order { <<aggregate root>> -id : UUID +confirm() : void } class OrderConfirmedEvent { <<domain event>> -orderId : UUID +occurredOn : DateTime } Order --> OrderConfirmedEvent : \"publishes\"","title":"Domain Event \u2013 Something Happened"},{"location":"02_tactic_pattern/#application-service-orchestrating-use-cases","text":"An application service coordinates workflows by invoking domain objects and repositories, ensuring the correct sequence of operations. It manages transactions, orchestration, and security while delegating all business rules to the domain layer, keeping the domain pure and exposing use cases to the outside world. classDiagram class Order { <<aggregate root>> -id : UUID +confirm() : void } class OrderRepository { <<repository>> +findById(id: UUID) : Order +save(order: Order) : void } class OrderApplicationService { <<application service>> +confirmOrder(orderId: UUID) : void } OrderApplicationService --> OrderRepository : uses OrderApplicationService --> Order : orchestrates","title":"Application Service - Orchestrating Use Cases"},{"location":"03_01_lab/","text":"3 Lab 1: Hello World MicroProfile In this first lab, we will create a simple Hello World MicroProfile application using Helidon . The goal is to quickly bootstrap a project that we will later extend with DDD tactical patterns. Step 1: Access the Helidon Project Starter Open the official Helidon starter in your browser: \ud83d\udc49 https://helidon.io/starter Step 2: Select the Helidon Flavor On the first screen, select Helidon MP as the project flavor, then click Next . Step 3: Choose the Application Type On the \"Select an Application Type\" step, choose Quickstart , then click Next . Step 4: Choose the JSON Library On the \"Select a JSON Library\" step, select JSON-B , then click Next . Step 5: Customize the Project Fill in the project details as follows: Group Id : com.example Artifact Id : ecommerce Version : 1.0.0 Package : com.example.ecommerce Step 6: Download the Project Click on Download to generate and download your starter project. Step 7: Explore the Project After downloading the project, unzip it and open it in your favorite IDE. Step 8: Update the port number Open the src/main/resources/microprofile-config.properties file change the server.port property to 8181 . Step 9: Run the Application With JDK21 execute the following commands: mvn package java -jar target/ecommerce.jar Step 10: Test the Application curl -X GET http://localhost:8181/greet { \"message\" : \"Hello World!\" } curl -X GET http://localhost:8181/greet/Joe { \"message\" : \"Hello Joe!\" } curl -X PUT -H \"Content-Type: application/json\" -d '{\"greeting\" : \"Hola\"}' http://localhost:8181/greet/greeting curl -X GET http://localhost:8181/greet/Jose { \"message\" : \"Hola Jose!\" }","title":"3 Lab 1: Hello World MicroProfile"},{"location":"03_01_lab/#3-lab-1-hello-world-microprofile","text":"In this first lab, we will create a simple Hello World MicroProfile application using Helidon . The goal is to quickly bootstrap a project that we will later extend with DDD tactical patterns.","title":"3 Lab 1: Hello World MicroProfile"},{"location":"03_01_lab/#step-1-access-the-helidon-project-starter","text":"Open the official Helidon starter in your browser: \ud83d\udc49 https://helidon.io/starter","title":"Step 1: Access the Helidon Project Starter"},{"location":"03_01_lab/#step-2-select-the-helidon-flavor","text":"On the first screen, select Helidon MP as the project flavor, then click Next .","title":"Step 2: Select the Helidon Flavor"},{"location":"03_01_lab/#step-3-choose-the-application-type","text":"On the \"Select an Application Type\" step, choose Quickstart , then click Next .","title":"Step 3: Choose the Application Type"},{"location":"03_01_lab/#step-4-choose-the-json-library","text":"On the \"Select a JSON Library\" step, select JSON-B , then click Next .","title":"Step 4: Choose the JSON Library"},{"location":"03_01_lab/#step-5-customize-the-project","text":"Fill in the project details as follows: Group Id : com.example Artifact Id : ecommerce Version : 1.0.0 Package : com.example.ecommerce","title":"Step 5: Customize the Project"},{"location":"03_01_lab/#step-6-download-the-project","text":"Click on Download to generate and download your starter project.","title":"Step 6: Download the Project"},{"location":"03_01_lab/#step-7-explore-the-project","text":"After downloading the project, unzip it and open it in your favorite IDE.","title":"Step 7: Explore the Project"},{"location":"03_01_lab/#step-8-update-the-port-number","text":"Open the src/main/resources/microprofile-config.properties file change the server.port property to 8181 .","title":"Step 8: Update the port number"},{"location":"03_01_lab/#step-9-run-the-application","text":"With JDK21 execute the following commands: mvn package java -jar target/ecommerce.jar","title":"Step 9: Run the Application"},{"location":"03_01_lab/#step-10-test-the-application","text":"curl -X GET http://localhost:8181/greet { \"message\" : \"Hello World!\" } curl -X GET http://localhost:8181/greet/Joe { \"message\" : \"Hello Joe!\" } curl -X PUT -H \"Content-Type: application/json\" -d '{\"greeting\" : \"Hola\"}' http://localhost:8181/greet/greeting curl -X GET http://localhost:8181/greet/Jose { \"message\" : \"Hola Jose!\" }","title":"Step 10: Test the Application"},{"location":"04_02_lab/","text":"4 -Lab 2 -Stereotypes on CDI Step 1: Including Map struct in the project: At the pomx.xml file, at the dependencies section, add the following dependency: <dependency> <groupId> org.mapstruct </groupId> <artifactId> mapstruct </artifactId> <version> 1.6.3 </version> <scope> provided </scope> </dependency> <dependency> <groupId> org.mapstruct </groupId> <artifactId> mapstruct-processor </artifactId> <version> 1.6.3 </version> <scope> provided </scope> </dependency> Step 2: Include the annotations in the project: To represent easily the DDD concepts, we will use the stereotypes provided by CDI. At the package com.example.ecommerce.annotations we will create the following classes: @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface Repository { } @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface DomainService { } @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface ApplicationService { } Step 3: Define the Domain classes: At the package com.example.ecommerce.domain create the following classes: public record Money ( String currency , BigDecimal amount ) { } package com.example.ecommerce.domain ; import java.util.Objects ; public class Product { private String id ; private String name ; private Money price ; Product ( String id , String name , Money price ) { this . id = id ; this . name = name ; this . price = price ; } public String getId () { return id ; } public String getName () { return name ; } public Money getPrice () { return price ; } @Override public boolean equals ( Object o ) { if ( o == null || getClass () != o . getClass ()) { return false ; } Product product = ( Product ) o ; return Objects . equals ( id , product . id ); } @Override public int hashCode () { return Objects . hashCode ( id ); } @Override public String toString () { return \"Product{\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + \", price=\" + price + '}' ; } public static ProductBuilder builder () { return new ProductBuilder (); } } package com.example.ecommerce.domain ; public class ProductBuilder { private String id ; private String name ; private Money price ; public ProductBuilder id ( String id ) { this . id = id ; return this ; } public ProductBuilder name ( String name ) { this . name = name ; return this ; } public ProductBuilder price ( Money price ) { this . price = price ; return this ; } public Product build () { return new Product ( id , name , price ); } } public interface ProductRepository { Product save ( Product product ); Optional < Product > findById ( String id ); List < Product > findAll (); void deleteById ( String id ); } @ApplicationService public class ProductService { private final ProductRepository repository ; @Inject public ProductService ( ProductRepository repository ) { this . repository = repository ; } public Product save ( Product product ) { return repository . save ( product ); } public void deleteById ( String id ) { repository . deleteById ( id ); } public Optional < Product > findById ( String id ) { return repository . findById ( id ); } public List < Product > findAll () { return repository . findAll (); } } package com.example.ecommerce.infrastructure.persistence ; import com.example.ecommerce.annotations.Repository ; import com.example.ecommerce.domain.Product ; import com.example.ecommerce.domain.ProductRepository ; import java.util.* ; @Repository public class InMemoryProductRepository implements ProductRepository { private final Map < String , Product > store = new HashMap <> (); @Override public Product save ( Product product ) { store . put ( product . getId (), product ); return product ; } @Override public Optional < Product > findById ( String id ) { return Optional . ofNullable ( store . get ( id )); } @Override public List < Product > findAll () { return new ArrayList <> ( store . values ()); } @Override public void deleteById ( String id ) { store . remove ( id ); } } Step 4: Define the presentation classes: At the package com.example.ecommerce.presentation create the following classes: import java.math.BigDecimal ; public record ProductRequest ( String name , String currency , BigDecimal amount ) { } import java.math.BigDecimal ; public record ProductResponse ( String id , String name , String currency , BigDecimal amount ) { } import com.example.ecommerce.domain.Product ; import org.mapstruct.Mapper ; import org.mapstruct.Mapping ; import java.util.List ; @Mapper ( componentModel = \"cdi\" ) public interface ProductMapper { @Mapping ( target = \"id\" , expression = \"java(java.util.UUID.randomUUID().toString())\" ) @Mapping ( target = \"price.currency\" , source = \"dto.currency\" ) @Mapping ( target = \"price.amount\" , source = \"dto.amount\" ) Product toDomain ( ProductRequest dto ); @Mapping ( target = \"currency\" , source = \"price.currency\" ) @Mapping ( target = \"amount\" , source = \"price.amount\" ) ProductResponse toResponse ( Product product ); List < ProductResponse > toResponseList ( List < Product > products ); } package com.example.ecommerce.presentation ; import com.example.ecommerce.domain.Product ; import com.example.ecommerce.domain.ProductService ; import jakarta.enterprise.context.ApplicationScoped ; import jakarta.inject.Inject ; import jakarta.ws.rs.DELETE ; import jakarta.ws.rs.GET ; import jakarta.ws.rs.POST ; import jakarta.ws.rs.Path ; import jakarta.ws.rs.PathParam ; import jakarta.ws.rs.WebApplicationException ; import jakarta.ws.rs.core.Response ; import java.util.List ; @ApplicationScoped @Path ( \"/products\" ) public class ProductResource { private final ProductMapper mapper ; private final ProductService service ; @Inject public ProductResource ( ProductMapper mapper , ProductService service ) { this . mapper = mapper ; this . service = service ; } @GET public List < ProductResponse > getAllProducts () { return service . findAll (). stream () . map ( mapper :: toResponse ) . toList (); } @GET @Path ( \"/{id}\" ) public ProductResponse getProductById ( @PathParam ( \"id\" ) String id ) { return service . findById ( id ). map ( this . mapper :: toResponse ). orElseThrow ( () -> new WebApplicationException ( \"Product with id \" + id + \" not found\" , Response . Status . NOT_FOUND )); } @DELETE @Path ( \"/{id}\" ) public void deleteById ( @PathParam ( \"id\" ) String id ) { service . deleteById ( id ); } @POST public ProductResponse insert ( ProductRequest request ) { Product product = service . save ( mapper . toDomain ( request )); return mapper . toResponse ( product ); } } Step 5: Run the application: mvn package java -jar target/ecommerce.jar Step 6: Test the application: curl --location 'http://localhost:8181/products' \\ --header 'Content-Type: application/json' \\ --data '{\"name\": \"Pen\", \"currency\": \"USD\", \"amount\": 10}' curl --location 'http://localhost:8181/products' curl --location 'http://localhost:8181/products'","title":"4 -Lab 2 -Stereotypes on CDI"},{"location":"04_02_lab/#4-lab-2-stereotypes-on-cdi","text":"","title":"4 -Lab 2 -Stereotypes on CDI"},{"location":"04_02_lab/#step-1-including-map-struct-in-the-project","text":"At the pomx.xml file, at the dependencies section, add the following dependency: <dependency> <groupId> org.mapstruct </groupId> <artifactId> mapstruct </artifactId> <version> 1.6.3 </version> <scope> provided </scope> </dependency> <dependency> <groupId> org.mapstruct </groupId> <artifactId> mapstruct-processor </artifactId> <version> 1.6.3 </version> <scope> provided </scope> </dependency>","title":"Step 1: Including Map struct in the project:"},{"location":"04_02_lab/#step-2-include-the-annotations-in-the-project","text":"To represent easily the DDD concepts, we will use the stereotypes provided by CDI. At the package com.example.ecommerce.annotations we will create the following classes: @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface Repository { } @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface DomainService { } @Stereotype @ApplicationScoped @Inherited @Retention ( RUNTIME ) @Target ( ElementType . TYPE ) public @interface ApplicationService { }","title":"Step 2: Include the annotations in the project:"},{"location":"04_02_lab/#step-3-define-the-domain-classes","text":"At the package com.example.ecommerce.domain create the following classes: public record Money ( String currency , BigDecimal amount ) { } package com.example.ecommerce.domain ; import java.util.Objects ; public class Product { private String id ; private String name ; private Money price ; Product ( String id , String name , Money price ) { this . id = id ; this . name = name ; this . price = price ; } public String getId () { return id ; } public String getName () { return name ; } public Money getPrice () { return price ; } @Override public boolean equals ( Object o ) { if ( o == null || getClass () != o . getClass ()) { return false ; } Product product = ( Product ) o ; return Objects . equals ( id , product . id ); } @Override public int hashCode () { return Objects . hashCode ( id ); } @Override public String toString () { return \"Product{\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + \", price=\" + price + '}' ; } public static ProductBuilder builder () { return new ProductBuilder (); } } package com.example.ecommerce.domain ; public class ProductBuilder { private String id ; private String name ; private Money price ; public ProductBuilder id ( String id ) { this . id = id ; return this ; } public ProductBuilder name ( String name ) { this . name = name ; return this ; } public ProductBuilder price ( Money price ) { this . price = price ; return this ; } public Product build () { return new Product ( id , name , price ); } } public interface ProductRepository { Product save ( Product product ); Optional < Product > findById ( String id ); List < Product > findAll (); void deleteById ( String id ); } @ApplicationService public class ProductService { private final ProductRepository repository ; @Inject public ProductService ( ProductRepository repository ) { this . repository = repository ; } public Product save ( Product product ) { return repository . save ( product ); } public void deleteById ( String id ) { repository . deleteById ( id ); } public Optional < Product > findById ( String id ) { return repository . findById ( id ); } public List < Product > findAll () { return repository . findAll (); } } package com.example.ecommerce.infrastructure.persistence ; import com.example.ecommerce.annotations.Repository ; import com.example.ecommerce.domain.Product ; import com.example.ecommerce.domain.ProductRepository ; import java.util.* ; @Repository public class InMemoryProductRepository implements ProductRepository { private final Map < String , Product > store = new HashMap <> (); @Override public Product save ( Product product ) { store . put ( product . getId (), product ); return product ; } @Override public Optional < Product > findById ( String id ) { return Optional . ofNullable ( store . get ( id )); } @Override public List < Product > findAll () { return new ArrayList <> ( store . values ()); } @Override public void deleteById ( String id ) { store . remove ( id ); } }","title":"Step 3: Define the Domain classes:"},{"location":"04_02_lab/#step-4-define-the-presentation-classes","text":"At the package com.example.ecommerce.presentation create the following classes: import java.math.BigDecimal ; public record ProductRequest ( String name , String currency , BigDecimal amount ) { } import java.math.BigDecimal ; public record ProductResponse ( String id , String name , String currency , BigDecimal amount ) { } import com.example.ecommerce.domain.Product ; import org.mapstruct.Mapper ; import org.mapstruct.Mapping ; import java.util.List ; @Mapper ( componentModel = \"cdi\" ) public interface ProductMapper { @Mapping ( target = \"id\" , expression = \"java(java.util.UUID.randomUUID().toString())\" ) @Mapping ( target = \"price.currency\" , source = \"dto.currency\" ) @Mapping ( target = \"price.amount\" , source = \"dto.amount\" ) Product toDomain ( ProductRequest dto ); @Mapping ( target = \"currency\" , source = \"price.currency\" ) @Mapping ( target = \"amount\" , source = \"price.amount\" ) ProductResponse toResponse ( Product product ); List < ProductResponse > toResponseList ( List < Product > products ); } package com.example.ecommerce.presentation ; import com.example.ecommerce.domain.Product ; import com.example.ecommerce.domain.ProductService ; import jakarta.enterprise.context.ApplicationScoped ; import jakarta.inject.Inject ; import jakarta.ws.rs.DELETE ; import jakarta.ws.rs.GET ; import jakarta.ws.rs.POST ; import jakarta.ws.rs.Path ; import jakarta.ws.rs.PathParam ; import jakarta.ws.rs.WebApplicationException ; import jakarta.ws.rs.core.Response ; import java.util.List ; @ApplicationScoped @Path ( \"/products\" ) public class ProductResource { private final ProductMapper mapper ; private final ProductService service ; @Inject public ProductResource ( ProductMapper mapper , ProductService service ) { this . mapper = mapper ; this . service = service ; } @GET public List < ProductResponse > getAllProducts () { return service . findAll (). stream () . map ( mapper :: toResponse ) . toList (); } @GET @Path ( \"/{id}\" ) public ProductResponse getProductById ( @PathParam ( \"id\" ) String id ) { return service . findById ( id ). map ( this . mapper :: toResponse ). orElseThrow ( () -> new WebApplicationException ( \"Product with id \" + id + \" not found\" , Response . Status . NOT_FOUND )); } @DELETE @Path ( \"/{id}\" ) public void deleteById ( @PathParam ( \"id\" ) String id ) { service . deleteById ( id ); } @POST public ProductResponse insert ( ProductRequest request ) { Product product = service . save ( mapper . toDomain ( request )); return mapper . toResponse ( product ); } }","title":"Step 4: Define the presentation classes:"},{"location":"04_02_lab/#step-5-run-the-application","text":"mvn package java -jar target/ecommerce.jar","title":"Step 5: Run the application:"},{"location":"04_02_lab/#step-6-test-the-application","text":"curl --location 'http://localhost:8181/products' \\ --header 'Content-Type: application/json' \\ --data '{\"name\": \"Pen\", \"currency\": \"USD\", \"amount\": 10}' curl --location 'http://localhost:8181/products' curl --location 'http://localhost:8181/products'","title":"Step 6: Test the application:"},{"location":"05_03_lab/","text":"5 -Lab 3 -Events on CDI In this event lab we will learn how to use DDD events exploring CDI events. Step 1: Create the event: import java.math.BigDecimal ; public record ProductPriceChanged ( String productId , BigDecimal oldPrice , BigDecimal newPrice ) { } Step 2: Create Update Product price domain event: package com.example.ecommerce.domain ; import com.example.ecommerce.annotations.DomainService ; import com.example.ecommerce.domain.events.ProductPriceChanged ; import jakarta.enterprise.event.Event ; import jakarta.inject.Inject ; import java.math.BigDecimal ; import java.util.Objects ; @DomainService public class UpdateProductPrice { private final ProductRepository repository ; private final Event < ProductPriceChanged > productPriceChangedEvent ; @Inject public UpdateProductPrice ( ProductRepository repository , Event < ProductPriceChanged > productPriceChangedEvent ) { this . repository = repository ; this . productPriceChangedEvent = productPriceChangedEvent ; } public void execute ( Product product , BigDecimal price ) { Objects . requireNonNull ( product , \"Product must not be null.\" ); Objects . requireNonNull ( price , \"Price must not be null.\" ); if ( price . compareTo ( BigDecimal . ZERO ) <= 0 ) { throw new IllegalArgumentException ( \"Price must be > 0.\" ); } var event = new ProductPriceChanged ( product . getId (), product . getPrice (). amount (), price ); this . productPriceChangedEvent . fire ( event ); product . update ( price ); this . repository . save ( product ); } } Update the Application class to call the new UpdateProductPrice service, thus update the class ProductService : import java.math.BigDecimal ; public record UpdatePriceRequest ( BigDecimal price ) { } package com.example.ecommerce.domain ; import com.example.ecommerce.annotations.ApplicationService ; import jakarta.inject.Inject ; import java.math.BigDecimal ; import java.util.List ; import java.util.Optional ; @ApplicationService public class ProductService { private final ProductRepository repository ; private final UpdateProductPrice updateProductPrice ; @Inject public ProductService ( ProductRepository repository , UpdateProductPrice updateProductPrice ) { this . repository = repository ; this . updateProductPrice = updateProductPrice ; } public Product save ( Product product ) { return repository . save ( product ); } public void deleteById ( String id ) { repository . deleteById ( id ); } public Optional < Product > findById ( String id ) { return repository . findById ( id ); } public List < Product > findAll () { return repository . findAll (); } public void changePrice ( String id , BigDecimal price ) { Product product = productRepository . findById ( id ) . orElseThrow (() -> new IllegalArgumentException ( \"Product with id \" + id + \" not found\" )); //we could improve this exception as well. this . updateProductPrice . execute ( product , price ); } } Update the Resource class to call the new method: @PATCH @Path ( \"{id}/price\" ) public void changePrice ( @PathParam ( \"id\" ) String id , UpdatePriceRequest body ) { service . changePrice ( id , body . price ()); } On the Product class also include the update method: public void update ( BigDecimal amount ) { this . price = new Money ( price . currency (), amount ); } Create a new class to listen to the event: package com.example.ecommerce.marketing ; import com.example.ecommerce.domain.events.ProductPriceChanged ; import jakarta.enterprise.context.ApplicationScoped ; import jakarta.enterprise.event.Observes ; import java.math.BigDecimal ; @ApplicationScoped public class SocialMediaPriceChangePublisher { public void onPriceChange ( @Observes ProductPriceChanged event ) { BigDecimal oldP = event . oldPrice (); BigDecimal newP = event . newPrice (); // demo behavior: print only when the price dropped if ( newP . compareTo ( oldP ) < 0 ) { System . out . println ( \"[SOCIAL] \ud83c\udf89 Promo! Product \" + event . productId () + \" dropped from \" + oldP + \" to \" + newP + \". #Sale #Deal\" ); } else { // keep it simple for the lab\u2014no op on increases System . out . println ( \"[SOCIAL] (ignored) price increased for \" + event . productId () + \" from \" + oldP + \" to \" + newP ); } } } Step 3: Execute the application and test the new endpoint: mvn package java -jar target/ecommerce.jar Step 4: Test the new endpoint: curl --location 'http://localhost:8181/products' \\ --header 'Content-Type: application/json' \\ --data '{\"name\": \"Pen\", \"currency\": \"USD\", \"amount\": 10}' curl --location --request PATCH 'http://localhost:8181/products/61c848a9-3bb8-4668-89c1-227cc6a4e049/price' \\ --header 'Content-Type: application/json' \\ --data '{\"price\": 6}'","title":"5 -Lab 3 -Events on CDI"},{"location":"05_03_lab/#5-lab-3-events-on-cdi","text":"In this event lab we will learn how to use DDD events exploring CDI events.","title":"5 -Lab 3 -Events on CDI"},{"location":"05_03_lab/#step-1-create-the-event","text":"import java.math.BigDecimal ; public record ProductPriceChanged ( String productId , BigDecimal oldPrice , BigDecimal newPrice ) { }","title":"Step 1: Create the event:"},{"location":"05_03_lab/#step-2-create-update-product-price-domain-event","text":"package com.example.ecommerce.domain ; import com.example.ecommerce.annotations.DomainService ; import com.example.ecommerce.domain.events.ProductPriceChanged ; import jakarta.enterprise.event.Event ; import jakarta.inject.Inject ; import java.math.BigDecimal ; import java.util.Objects ; @DomainService public class UpdateProductPrice { private final ProductRepository repository ; private final Event < ProductPriceChanged > productPriceChangedEvent ; @Inject public UpdateProductPrice ( ProductRepository repository , Event < ProductPriceChanged > productPriceChangedEvent ) { this . repository = repository ; this . productPriceChangedEvent = productPriceChangedEvent ; } public void execute ( Product product , BigDecimal price ) { Objects . requireNonNull ( product , \"Product must not be null.\" ); Objects . requireNonNull ( price , \"Price must not be null.\" ); if ( price . compareTo ( BigDecimal . ZERO ) <= 0 ) { throw new IllegalArgumentException ( \"Price must be > 0.\" ); } var event = new ProductPriceChanged ( product . getId (), product . getPrice (). amount (), price ); this . productPriceChangedEvent . fire ( event ); product . update ( price ); this . repository . save ( product ); } } Update the Application class to call the new UpdateProductPrice service, thus update the class ProductService : import java.math.BigDecimal ; public record UpdatePriceRequest ( BigDecimal price ) { } package com.example.ecommerce.domain ; import com.example.ecommerce.annotations.ApplicationService ; import jakarta.inject.Inject ; import java.math.BigDecimal ; import java.util.List ; import java.util.Optional ; @ApplicationService public class ProductService { private final ProductRepository repository ; private final UpdateProductPrice updateProductPrice ; @Inject public ProductService ( ProductRepository repository , UpdateProductPrice updateProductPrice ) { this . repository = repository ; this . updateProductPrice = updateProductPrice ; } public Product save ( Product product ) { return repository . save ( product ); } public void deleteById ( String id ) { repository . deleteById ( id ); } public Optional < Product > findById ( String id ) { return repository . findById ( id ); } public List < Product > findAll () { return repository . findAll (); } public void changePrice ( String id , BigDecimal price ) { Product product = productRepository . findById ( id ) . orElseThrow (() -> new IllegalArgumentException ( \"Product with id \" + id + \" not found\" )); //we could improve this exception as well. this . updateProductPrice . execute ( product , price ); } } Update the Resource class to call the new method: @PATCH @Path ( \"{id}/price\" ) public void changePrice ( @PathParam ( \"id\" ) String id , UpdatePriceRequest body ) { service . changePrice ( id , body . price ()); } On the Product class also include the update method: public void update ( BigDecimal amount ) { this . price = new Money ( price . currency (), amount ); } Create a new class to listen to the event: package com.example.ecommerce.marketing ; import com.example.ecommerce.domain.events.ProductPriceChanged ; import jakarta.enterprise.context.ApplicationScoped ; import jakarta.enterprise.event.Observes ; import java.math.BigDecimal ; @ApplicationScoped public class SocialMediaPriceChangePublisher { public void onPriceChange ( @Observes ProductPriceChanged event ) { BigDecimal oldP = event . oldPrice (); BigDecimal newP = event . newPrice (); // demo behavior: print only when the price dropped if ( newP . compareTo ( oldP ) < 0 ) { System . out . println ( \"[SOCIAL] \ud83c\udf89 Promo! Product \" + event . productId () + \" dropped from \" + oldP + \" to \" + newP + \". #Sale #Deal\" ); } else { // keep it simple for the lab\u2014no op on increases System . out . println ( \"[SOCIAL] (ignored) price increased for \" + event . productId () + \" from \" + oldP + \" to \" + newP ); } } }","title":"Step 2: Create Update Product price domain event:"},{"location":"05_03_lab/#step-3-execute-the-application-and-test-the-new-endpoint","text":"mvn package java -jar target/ecommerce.jar","title":"Step 3: Execute the application and test the new endpoint:"},{"location":"05_03_lab/#step-4-test-the-new-endpoint","text":"curl --location 'http://localhost:8181/products' \\ --header 'Content-Type: application/json' \\ --data '{\"name\": \"Pen\", \"currency\": \"USD\", \"amount\": 10}' curl --location --request PATCH 'http://localhost:8181/products/61c848a9-3bb8-4668-89c1-227cc6a4e049/price' \\ --header 'Content-Type: application/json' \\ --data '{\"price\": 6}'","title":"Step 4: Test the new endpoint:"},{"location":"06_04_lab/","text":"6 -Lab 4 Exploring ArchUnit In this lab we will explore ArchUnit and include more architecture rules exploring the use of ArchUnit. Step 1: Include ArchUnit in the project At the \u00b4pom.xml` file, include righ after the version tag the following: <properties> <jmolecules.version> 1.9.0 </jmolecules.version> </properties> At the \u00b4pom.xml` file, at the dependencies section, add the following dependency: <dependency> <groupId> org.jmolecules </groupId> <artifactId> jmolecules-ddd </artifactId> <version> ${jmolecules.version} </version> </dependency> <dependency> <groupId> org.jmolecules </groupId> <artifactId> jmolecules-layered-architecture </artifactId> <version> ${jmolecules.version} </version> </dependency> <dependency> <groupId> org.jmolecules.integrations </groupId> <artifactId> jmolecules-archunit </artifactId> <version> 0.28.0 </version> <scope> test </scope> </dependency> Step 2: Create a new rule Create a new class at the src/test/java/com/example/ folder named ArchitectureTest.java with the following content: package com.example.ecommerce ; import com.tngtech.archunit.core.domain.JavaClasses ; import com.tngtech.archunit.core.importer.ClassFileImporter ; import com.tngtech.archunit.lang.syntax.ArchRuleDefinition ; import org.junit.jupiter.api.Test ; public class ArchitectureTest { @Test void domainClassesShouldNotDependOnApplicationLayer () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses importedClasses = new ClassFileImporter (). importPackages ( packageName ); ArchRuleDefinition . noClasses () . that (). resideInAPackage ( packageName ) . should (). dependOnClassesThat (). resideInAPackage ( \"..application..\" ) . check ( importedClasses ); } } package com.example.ecommerce ; import com.tngtech.archunit.core.domain.JavaClasses ; import com.tngtech.archunit.core.importer.ClassFileImporter ; import org.jmolecules.archunit.JMoleculesArchitectureRules ; import org.jmolecules.archunit.JMoleculesDddRules ; import org.junit.jupiter.api.Test ; public class JMoleculesDddUnitTest { @Test void checkTheLayerIntegration () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses classes = new ClassFileImporter (). importPackages ( packageName ); JMoleculesArchitectureRules . ensureLayering (). check ( classes ); } @Test void checkDDDIntegration () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses classes = new ClassFileImporter (). importPackages ( packageName ); JMoleculesDddRules . all (). check ( classes ); } } Step 3: Run the tests Run the tests and check the results. Also, please, explore both ArchUnit rules and the JMolecules rules: Jmolecules Archunit","title":"6 -Lab 4 Exploring ArchUnit"},{"location":"06_04_lab/#6-lab-4-exploring-archunit","text":"In this lab we will explore ArchUnit and include more architecture rules exploring the use of ArchUnit.","title":"6 -Lab 4 Exploring ArchUnit"},{"location":"06_04_lab/#step-1-include-archunit-in-the-project","text":"At the \u00b4pom.xml` file, include righ after the version tag the following: <properties> <jmolecules.version> 1.9.0 </jmolecules.version> </properties> At the \u00b4pom.xml` file, at the dependencies section, add the following dependency: <dependency> <groupId> org.jmolecules </groupId> <artifactId> jmolecules-ddd </artifactId> <version> ${jmolecules.version} </version> </dependency> <dependency> <groupId> org.jmolecules </groupId> <artifactId> jmolecules-layered-architecture </artifactId> <version> ${jmolecules.version} </version> </dependency> <dependency> <groupId> org.jmolecules.integrations </groupId> <artifactId> jmolecules-archunit </artifactId> <version> 0.28.0 </version> <scope> test </scope> </dependency>","title":"Step 1: Include ArchUnit in the project"},{"location":"06_04_lab/#step-2-create-a-new-rule","text":"Create a new class at the src/test/java/com/example/ folder named ArchitectureTest.java with the following content: package com.example.ecommerce ; import com.tngtech.archunit.core.domain.JavaClasses ; import com.tngtech.archunit.core.importer.ClassFileImporter ; import com.tngtech.archunit.lang.syntax.ArchRuleDefinition ; import org.junit.jupiter.api.Test ; public class ArchitectureTest { @Test void domainClassesShouldNotDependOnApplicationLayer () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses importedClasses = new ClassFileImporter (). importPackages ( packageName ); ArchRuleDefinition . noClasses () . that (). resideInAPackage ( packageName ) . should (). dependOnClassesThat (). resideInAPackage ( \"..application..\" ) . check ( importedClasses ); } } package com.example.ecommerce ; import com.tngtech.archunit.core.domain.JavaClasses ; import com.tngtech.archunit.core.importer.ClassFileImporter ; import org.jmolecules.archunit.JMoleculesArchitectureRules ; import org.jmolecules.archunit.JMoleculesDddRules ; import org.junit.jupiter.api.Test ; public class JMoleculesDddUnitTest { @Test void checkTheLayerIntegration () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses classes = new ClassFileImporter (). importPackages ( packageName ); JMoleculesArchitectureRules . ensureLayering (). check ( classes ); } @Test void checkDDDIntegration () { String packageName = SimpleGreetResource . class . getPackageName (); JavaClasses classes = new ClassFileImporter (). importPackages ( packageName ); JMoleculesDddRules . all (). check ( classes ); } }","title":"Step 2: Create a new rule"},{"location":"06_04_lab/#step-3-run-the-tests","text":"Run the tests and check the results. Also, please, explore both ArchUnit rules and the JMolecules rules: Jmolecules Archunit","title":"Step 3: Run the tests"},{"location":"07_05_lab/","text":"7 - Lab 5 Exploring Jakarta Data Step 1: Make sure that the database is running. Check the database setup at: https://github.com/o-s-expert/ddd-workshop-labs?tab=readme-ov-file#database-setup Step 2: Add the Jakarta Data dependency At the pom.xml file at the properties section add the following dependency: <jnosql.version> 1.1.10 </jnosql.version> On the dependencies section add the following dependency: <!-- <dependency> <groupId>org.eclipse.jnosql.databases</groupId> <artifactId>jnosql-mongodb</artifactId> <version>${jnosql.version}</version> </dependency>--> <dependency> <groupId> org.eclipse.jnosql.databases </groupId> <artifactId> jnosql-oracle-nosql </artifactId> <version> ${jnosql.version} </version> </dependency> Here we have the option of two databases: Oracle NoSQL and MongoDB. At the microprofile-config.properties file add the following properties: #JNoSQL configuration jnosql.keyvalue.database = products jnosql.document.database = products # Oracle NoSQL properties jnosql.oracle.nosql.host = http://localhost:8080 # MongoDB properties jnosql.mongodb.url = mongodb://localhost:27017 Step 3: Update the Repository This step will update the annotations using the Jakarta Data API, thus at the ProductRepository update the code: @Repository public interface ProductRepository { @Save Product save ( Product product ); Optional < Product > findById ( String id ); List < Product > findAll (); void deleteById ( String id ); } You can either remove the InMemoryProductRepository the whole class or just the @Repository annotation. Step 4: Update the Model domain Update the Product class to use the Jakarta NosQL annotations: import jakarta.nosql.Column ; import jakarta.nosql.Embeddable ; import java.math.BigDecimal ; @Embeddable ( Embeddable . EmbeddableType . GROUPING ) public record Money ( @Column String currency , @Column BigDecimal amount ) { } package com.example.ecommerce.domain ; import jakarta.nosql.Column ; import jakarta.nosql.Entity ; import jakarta.nosql.Id ; import java.math.BigDecimal ; import java.util.Objects ; @Entity public class Product { @Id private String id ; @Column private String name ; @Column private Money price ; Product ( String id , String name , Money price ) { this . id = id ; this . name = name ; this . price = price ; } Product () { } public String getId () { return id ; } public String getName () { return name ; } public Money getPrice () { return price ; } @Override public boolean equals ( Object o ) { if ( o == null || getClass () != o . getClass ()) { return false ; } Product product = ( Product ) o ; return Objects . equals ( id , product . id ); } @Override public int hashCode () { return Objects . hashCode ( id ); } @Override public String toString () { return \"Product{\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + \", price=\" + price + '}' ; } public static ProductBuilder builder () { return new ProductBuilder (); } public void update ( BigDecimal amount ) { this . price = new Money ( price . currency (), amount ); } }","title":"7 - Lab 5 Exploring Jakarta Data"},{"location":"07_05_lab/#7-lab-5-exploring-jakarta-data","text":"","title":"7 - Lab 5 Exploring Jakarta Data"},{"location":"07_05_lab/#step-1-make-sure-that-the-database-is-running","text":"Check the database setup at: https://github.com/o-s-expert/ddd-workshop-labs?tab=readme-ov-file#database-setup","title":"Step 1: Make sure that the database is running."},{"location":"07_05_lab/#step-2-add-the-jakarta-data-dependency","text":"At the pom.xml file at the properties section add the following dependency: <jnosql.version> 1.1.10 </jnosql.version> On the dependencies section add the following dependency: <!-- <dependency> <groupId>org.eclipse.jnosql.databases</groupId> <artifactId>jnosql-mongodb</artifactId> <version>${jnosql.version}</version> </dependency>--> <dependency> <groupId> org.eclipse.jnosql.databases </groupId> <artifactId> jnosql-oracle-nosql </artifactId> <version> ${jnosql.version} </version> </dependency> Here we have the option of two databases: Oracle NoSQL and MongoDB. At the microprofile-config.properties file add the following properties: #JNoSQL configuration jnosql.keyvalue.database = products jnosql.document.database = products # Oracle NoSQL properties jnosql.oracle.nosql.host = http://localhost:8080 # MongoDB properties jnosql.mongodb.url = mongodb://localhost:27017","title":"Step 2: Add the Jakarta Data dependency"},{"location":"07_05_lab/#step-3-update-the-repository","text":"This step will update the annotations using the Jakarta Data API, thus at the ProductRepository update the code: @Repository public interface ProductRepository { @Save Product save ( Product product ); Optional < Product > findById ( String id ); List < Product > findAll (); void deleteById ( String id ); } You can either remove the InMemoryProductRepository the whole class or just the @Repository annotation.","title":"Step 3: Update the Repository"},{"location":"07_05_lab/#step-4-update-the-model-domain","text":"Update the Product class to use the Jakarta NosQL annotations: import jakarta.nosql.Column ; import jakarta.nosql.Embeddable ; import java.math.BigDecimal ; @Embeddable ( Embeddable . EmbeddableType . GROUPING ) public record Money ( @Column String currency , @Column BigDecimal amount ) { } package com.example.ecommerce.domain ; import jakarta.nosql.Column ; import jakarta.nosql.Entity ; import jakarta.nosql.Id ; import java.math.BigDecimal ; import java.util.Objects ; @Entity public class Product { @Id private String id ; @Column private String name ; @Column private Money price ; Product ( String id , String name , Money price ) { this . id = id ; this . name = name ; this . price = price ; } Product () { } public String getId () { return id ; } public String getName () { return name ; } public Money getPrice () { return price ; } @Override public boolean equals ( Object o ) { if ( o == null || getClass () != o . getClass ()) { return false ; } Product product = ( Product ) o ; return Objects . equals ( id , product . id ); } @Override public int hashCode () { return Objects . hashCode ( id ); } @Override public String toString () { return \"Product{\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + \", price=\" + price + '}' ; } public static ProductBuilder builder () { return new ProductBuilder (); } public void update ( BigDecimal amount ) { this . price = new Money ( price . currency (), amount ); } }","title":"Step 4: Update the Model domain"}]}